---
title: "Bioinformatics project year 2023/2024"
author: "Lucia Anna Mellini"
date:
#bibliography: references.bib
output: 
    html_notebook:
        toc: true
        number_sections: true
        toc_float: true
        theme: cerulean
        fig_caption: true
---


```{r message=FALSE, warning=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("curatedTCGAData") 
BiocManager::install("TCGAutils") 
BiocManager::install("TCGAbiolinks") 

install.packages("SNFtool");
install.packages("NetPreProc")
install.packages("caret")
install.packages("cluster")
install.packages("mclustcomp")
```
```{r message=FALSE, warning=FALSE}
library("curatedTCGAData") 
library("TCGAbiolinks") 
library("TCGAutils") 

library("SNFtool")
library("NetPreProc") 
library("caret")
library("cluster")
library("mclustcomp")
```
# Download Prostate adenocarcinoma dataset#
<!-- miRNASeqGene              Gene-level log2 RPM miRNA expression values
<>RNASeq2Gene               RSEM TPM gene expression values
<>RPPAArray                 Reverse Phase Protein Array normalized protein expression values -->
```{r}

assays <- c("miRNASeqGene", "RNASeq2Gene", "RPPAArray") 
mo <- curatedTCGAData(diseaseCode = "PRAD", 
                        assays = assays,
                        version = "2.0.1", dry.run=FALSE) 
```
# Data pre-processing
Consider only primary solid tumors
Analyte information missing from PRAD_RPPAArray (20th position) that causes inconsistent barcode lengths in MultiArrayExperiment object  ```mo``` (but doesn't cause problems for the code below).
```{r message=FALSE, warning=FALSE}
primary <- TCGAutils::TCGAsampleSelect(colnames(mo), c("01")) 
mo <- mo[,primary,]
```
Check for replicates for same patient (first 12 characters)
No replicates present in ```mo```.
```{r}
check_rep <- anyReplicated(mo) 
print(check_rep)
```
Remove FFPE samples (frozen tissue is better preseved)
```{r}
no_ffpe <- which(as.data.frame(colData(mo))$patient.samples.sample.is_ffpe == "no") 
#as.data.frame(colData(mo))
mo <- mo[, no_ffpe, ] 
```
Consider samples having all considered omics data
```{r}
complete <- intersectColumns(mo) 
```
ExpressionList â†’ simple list of matrices
```{r}
complete <- assays(complete)
```
Transpose all three matrices, obtaining samples $\times$ features
```{r}
complete <- lapply(complete,FUN=t)
```
Remove features having missing values (no missing values in the current dataset)
```{r}
for (i in 1:length(complete)){
  #print(dim(complete[[i]]))
  complete[[i]] <- complete[[i]][,colSums(is.na(complete[[i]]))==0]
  #print(dim(complete[[i]]))
}
```
Select features having more variance across samples because they bring more information.
```{r}
nf <- 100 
for(i in 1:length(complete)){
    
    idx <- caret::nearZeroVar(complete[[i]])
    message(paste("Removed ", length(idx), "features from", names(complete)[i])) 
    if(length(idx) != 0){
        complete[[i]] <- complete[[i]][, -idx] 
    }

    if(ncol(complete[[i]]) <= nf) next
    
    vars <- apply(complete[[i]], 2, var) 
    idx <- sort(vars, index.return=TRUE, decreasing = TRUE)$ix 
    
    complete[[i]] <- complete[[i]][, idx[1:nf]] 
    
}
```

Standardize features with z-score
```{r}
zscore <- function(data){
    
    zscore_vec <- function(x) { return ((x - mean(x)) / sd(x))}
    data <- apply(data, 2, zscore_vec)
    
    
    return(data)
}

complete <- lapply(complete, zscore) 
```
Clean barcodes retaining only "Project-TSS-Participant" (first 12 characters)
```{r}
for(v in 1:length(complete)){
    rownames(complete[[v]]) <- substr(rownames(complete[[v]]), 1, 12) 
}
```
# Download disease subtypes
```{r}
subtypes <- as.data.frame(TCGAbiolinks::PanCancerAtlas_subtypes())

subtypes <- subtypes[subtypes$cancer.type == "PRAD", ] 
# Retain only primary solid tumors and select samples in common with omics data
# (in the same order):
subtypes <- subtypes[TCGAutils::TCGAsampleSelect(subtypes$pan.samplesID, "01"), ] 
sub_select <- substr(subtypes$pan.samplesID,1,12) %in% rownames(complete[[1]]) 
subtypes <- subtypes[sub_select, ] 
```
We consider only samples in the omics data in ```complete``` for which also subtype data is present in ```subtypes```
```{r}
rownames(subtypes) <- substr(subtypes$pan.samplesID, 1, 12) 
for (i in 1:length(complete))
  complete[[i]] <- complete[[i]][rownames(subtypes),]
# Print number of samples for each subtype:
table(subtypes$Subtype_Integrative) 
```
## Check subtype & omics data order
```{r}
count <- 0
for(i in 1:length(rownames(subtypes))){
  if(rownames(subtypes)[i] != rownames(complete[[1]])[i])
     count <- count + 1
}
count
```
All patients/samples are in the same order in both the datasets.
# Multi-omics data integration
Similarity matrices for each data source using exponential euclidian distance (affinity matrix).
```{r}
W_list <- list();
for(i in 1:length(complete)){
    Dist <- (dist2(as.matrix(complete[[i]]), as.matrix(complete[[i]])))^(1/2);
    W_list[[i]] <- affinityMatrix(Dist);
}
```

## Integration through SNF
Integration of the matrices using Similarity Network Fusion
*_t_ number of iterations
*_K_ number of neighbours to consider to compute local similarity matrix

```{r}
W_int_SNF <- SNF(W_list, K=20, t=20)
```
## Integration through average
Integration through average of matrices
```{r}
W_int_mean <- Reduce('+', W_list)/length(W_list)
```
# Disease subtype discovery with PAM
Number of clusters.
```{r}
k <- length(unique(subtypes$Subtype_Integrative)) 
```
## Each data source
Convert similarity matrix into a distance matrix. The similarities are normalized in the range &\left[0, 1\right]$ using min-max normalization before conversion into distances.
```{r}
dist <- list()
D <- list()
pam.res <- list()
for (i in 1:length((W_list))){
  dist[[i]] <- 1 - NetPreProc::Max.Min.norm(W_list[[i]])
  D[[i]] <- as.dist(dist[[i]])
}
for (i in 1:length((W_list)))
  pam.res[[i]] <- pam(D[[i]], k=k)
```
## Integrated data through mean
```{r}
dist_mean <- 1 - NetPreProc::Max.Min.norm(W_int_mean) 
D_mean <- as.dist(dist_mean)  

pam.mean.res <- pam(D_mean, k=k) 
```
## Integrated data through SNF
```{r}
dist_SNF <- 1 - NetPreProc::Max.Min.norm(W_int_SNF) 
D_SNF <- as.dist(dist_SNF)  

# Apply clustering algorithms on integrated matrix:
pam.SNF.res <- pam(D_SNF, k=k) 
```
#Disease subtype discovery with spectral clustering
(Consider distance matrix calculated above)
## Integrated data through SNF
```{r}
sc.res <- SNFtool::spectralClustering(W_int_SNF, K=k)
#to have uniform type
sc.res <- pam(sc.res,k=k)
```


#Comparing obtained clusterings with molecular disease subtypes
Convert disease subtypes to numeric vectors
```{r}
labels <- as.numeric(factor(subtypes$Subtype_Integrative, levels=unique(subtypes$Subtype_Integrative)))
```
Chosen indeces to measure cluster quality
* Counting pairs
** Adjusted Rand index
** Jaccard index
** Rand index
* Set overlaps/matching
** F-measure
* Information theory
** Joint entropy
** Normalized Mutual Information (by Strehl & Ghosh)
```{r}
types <- c("adjrand", "jaccard", "rand", "f", "jent",  "nmi1");
```

##Non-integrated data - clustering with PAM
```{r}
df <- dataframe()
#names(complete)
for (i in 1:length(complete)){
  metrics.pam <- mclustcomp(pam.res[[i]]$clustering, labels, types=types);

  print(as.data.frame(metrics.pam));
}

```
## Data integrated through SNF - clustering with PAM
```{r}
metrics.pam <- mclustcomp(pam.SNF.res$clustering, labels, types=types);

as.data.frame(metrics.pam);
```
## Data integrated though mean - clustering with PAM
```{r}
metrics.pam <- mclustcomp(pam.mean.res$clustering, labels, types=types);

as.data.frame(metrics.pam);
```
## Data integrated through SNF - spectral clustering

```{r}
metrics.pam <- mclustcomp(sc.res$clustering, labels, types=types);

as.data.frame(metrics.pam);
```
```{r}
for (i in 1:length(complete))
  plot(complete[[i]])
```
Representation of distance matrix obtained by in Euclidian space using Multidimensional Scaling.
* integration though SNF
```{r}
mds <- cmdscale(D_SNF, k = 2)
x <- mds[,1]
y <- mds[,2]

plot(x,y, pch=16)
```
* integration through mean
```{r}
mds <- cmdscale(D_mean, k = 2)
x <- mds[,1]
y <- mds[,2]

plot(x,y, pch=16)
```
```{r}
?clusplot
clusplot(pam.mean.res, main="", cex=0.9, col.p=pam.mean.res$cluster, plotchar=FALSE)
clusplot(pam.SNF.res, main ="", cex=0.9, col.p=pam.SNF.res$cluster, plotchar=FALSE)
```
```{r}
sessionInfo()
```

