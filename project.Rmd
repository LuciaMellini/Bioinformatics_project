---
title: "Disease subtype discovery using
multi-omics data integration"
subtitle: "Bioinformatics project"
author: "Lucia Anna Mellini"
date: "year 2023/2024"
bibliography: references.bib
output: 
    html_notebook:
        toc: true
        number_sections: true
        toc_float: true
        theme: cerulean
        fig_caption: true
---

Install and load used packages.
```{r message=FALSE, warning=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("curatedTCGAData") 
BiocManager::install("TCGAutils") 
BiocManager::install("TCGAbiolinks") 

install.packages("SNFtool");
install.packages("NetPreProc")
install.packages("caret")
install.packages("cluster")
install.packages("mclustcomp")
```
```{r message=FALSE, warning=FALSE}
library("curatedTCGAData") 
library("TCGAbiolinks") 
library("TCGAutils") 

library("SNFtool")
library("NetPreProc") 
library("caret")
library("cluster")
library("mclustcomp")
```
# Prostate adenocarcinoma multi-omics dataset
In this project we will be using multi-omics data from a dataset from The Cancer Genome Atlas (TCGA) regarding Prostate adenocarcinoma (disease code "PRAD").
Using the _curatedTCGAData_ package it is possibile to download different views of the TCGA dataset
In particular we will be looking at:
* miRNA data      (_miRNASeqGene_ - gene-level miRNA normalized expression values)
* mRNA data       (_RNASeq2Gene_ - gene expressione values)
* protein data    (_RPPAArray_ - Reverse Phase Protein Array normalized protein expression values)
```{r}
assays <- c("miRNASeqGene", "RNASeq2Gene", "RPPAArray") 
mo <- curatedTCGAData(diseaseCode = "PRAD", 
                        assays = assays,
                        version = "2.0.1", dry.run=FALSE) 
```
A summary of the imported data stored in a MultiArrayExperiment object:
```{r}
mo
```
# Data pre-processing
We choose to consider only primary solid tumors. The information about the type of sample analyzed (i.e. primary, metastatic, solid, blood derived, etc.) is specified in the barcode of the sample by 2 numeric characters in the 13th and 14th position (for more information about TCGA [barcodes](https://docs.gdc.cancer.gov/Encyclopedia/pages/TCGA_Barcode/)). Primary solid tumors are identified by "01".
For the dataset in question the length of the barcodes is one character shorter for the data view _PRAD_RPPAArray_, in fact the specification of analyte information for the samples is missing in the 20th position of the barcode. Seen that in the evaluation phase we consider only the first 12 characters of the barcode, concerning a specific individual (fields Project, Tissue Source Site(TSS)  and Participant), this difference is irrelevant for this project.
```{r message=FALSE, warning=FALSE}
primary <- TCGAutils::TCGAsampleSelect(colnames(mo), c("01")) 
mo <- mo[,primary,]
```
We do not want to avoid working with replicates for the same sample, so we check that the first 12 characters in the barcode, indicating the identifier for the sample, are unique in the multi-omics dataset. It emerges that indeed there are no replicated samples.
```{r}
check_rep <- anyReplicated(mo) 
print(check_rep)
```
Also, we want to take into account only samples that have been preserved by freezing. seen that formalin-fixed, paraffin-embedded (FFPE) biopsies are preserved worse.
```{r}
no_ffpe <- which(as.data.frame(colData(mo))$patient.samples.sample.is_ffpe == "no") 
#as.data.frame(colData(mo))
mo <- mo[, no_ffpe, ] 
```
Obviously we want to look at the samples from three points of view, so we keep only those that are present in all three data views in the multi-omics dataset.
```{r}
complete <- intersectColumns(mo) 
```
For convenience's sake we transform each of the three _ExpressionList_s in ```mo``` in simple matrices.
```{r}
complete <- assays(complete)
```
To help computation we also transpose all matrices, obtaining tables with a row for each sample, and the columns containing the relative features.
```{r}
complete <- lapply(complete,FUN=t)
```
FIt would also be ideal to not have to deal with missing values. It turns out that in the samples in the current dataset there are none.
```{r}
for (i in 1:length(complete)){
  dim_prev <- dim(complete[[i]])
  complete[[i]] <- complete[[i]][,colSums(is.na(complete[[i]]))==0]
  print(dim(complete[[i]])-dim_prev)
}
```
Subsequently we select features having more variance across samples. The idea is that such data brings more information, and so is more relevant. In this case we consider only the first 100 features with highest variance.
```{r}
nf <- 100 
for(i in 1:length(complete)){
    
    idx <- caret::nearZeroVar(complete[[i]])
    message(paste("Removed ", length(idx), "features from", names(complete)[i])) 
    if(length(idx) != 0){
        complete[[i]] <- complete[[i]][, -idx] 
    }

    if(ncol(complete[[i]]) <= nf) next
    
    vars <- apply(complete[[i]], 2, var) 
    idx <- sort(vars, index.return=TRUE, decreasing = TRUE)$ix 
    
    complete[[i]] <- complete[[i]][, idx[1:nf]] 
    
}
```
We then standardize such features with z-score.
```{r}
zscore <- function(data){
    
    zscore_vec <- function(x) { return ((x - mean(x)) / sd(x))}
    data <- apply(data, 2, zscore_vec)
    
    
    return(data)
}

complete <- lapply(complete, zscore) 
```
Lastly, we clean the TCGA barcodes, retaining only the first 12 characters that specify the sample's Project, TSS and Participant.
```{r}
for(v in 1:length(complete)){
    rownames(complete[[v]]) <- substr(rownames(complete[[v]]), 1, 12) 
}
```
# Download disease subtypes
```{r}
subtypes <- as.data.frame(TCGAbiolinks::PanCancerAtlas_subtypes())

subtypes <- subtypes[subtypes$cancer.type == "PRAD", ]
```
Like for the multi-omics dataset we retain only primary solid tumors and keep the exclusively the first part of the TCGA barcode of the sample.
```{r}
subtypes <- subtypes[TCGAutils::TCGAsampleSelect(subtypes$pan.samplesID, "01"), ] 

sub_select <- substr(subtypes$pan.samplesID,1,12) %in% rownames(complete[[1]])
subtypes <- subtypes[sub_select, ] 
```
We consider only samples that are present both in the multi-omics and the subtype data. Seen that the subtype samples are a subset of those in the multi-omics data, it is sufficient to keep only that subset of rows in ```complete```.
```{r}
rownames(subtypes) <- substr(subtypes$pan.samplesID, 1, 12) 
for (i in 1:length(complete))
  complete[[i]] <- complete[[i]][rownames(subtypes),]
# Print number of samples for each subtype:
table(subtypes$Subtype_Integrative) 
```
To help with later evaluations we assure that the samples are in the same order in both the multi-omics and the subtype datasets that we are working with.
```{r}
for(i in 1:length(complete)){
  print(sum(rownames(subtypes) != rownames(complete[[i]])))
}
```
# Multi-omics data integration
The objective is to fuse the different types data from the multi-omics data into a unique object on which it is possible to evaluate the distance between the samples.
#For each integration method we present a a representation of the scaled distance matrix obtained from the similarity matrix given by integration (look at next step). The 2D plots are obtained by using Multidimensional Scaling on the distance matrices.
We start by finding the similarity matrix for each data source using exponential Euclidian distance, also called an affinity matrix.
```{r}
W_list <- list();
for(i in 1:length(complete)){
    Dist <- (dist2(as.matrix(complete[[i]]), as.matrix(complete[[i]])))^(1/2);
    W_list[[i]] <- affinityMatrix(Dist);
}
```
## Integration through SNF
Integration of the matrices using Similarity Network Fusion @wang2014similarity
* _t_ number of iterations
* _K_ number of neighbours to consider to compute local similarity matrix
```{r}
W_int_SNF <- SNF(W_list, K=20, t=20)
```
## Integration through average
Integration through average of matrices
```{r}
W_int_mean <- Reduce('+', W_list)/length(W_list)
```


# Disease subtype discovery with PAM
Number of clusters.
```{r}
k <- length(unique(subtypes$Subtype_Integrative)) 
```
## Each data source
Convert similarity matrix into a distance matrix. The similarities are normalized in the range &\left[0, 1\right]$ using min-max normalization before conversion into distances.
```{r}
dist <- list()
D <- list()
pam.res <- list()
for (i in 1:length((W_list))){
  dist[[i]] <- 1 - NetPreProc::Max.Min.norm(W_list[[i]])
  D[[i]] <- as.dist(dist[[i]])
}
for (i in 1:length((W_list)))
  pam.res[[i]] <- pam(D[[i]], k=k)
```
## Integrated data through mean
```{r}
dist_mean <- 1 - NetPreProc::Max.Min.norm(W_int_mean) 
D_mean <- as.dist(dist_mean)  

pam.mean.res <- pam(D_mean, k=k) 
```
## Integrated data through SNF
```{r}
dist_SNF <- 1 - NetPreProc::Max.Min.norm(W_int_SNF) 
D_SNF <- as.dist(dist_SNF)  

# Apply clustering algorithms on integrated matrix:
pam.SNF.res <- pam(D_SNF, k=k) 
```
#Disease subtype discovery with spectral clustering
(Consider distance matrix calculated above)
## Integrated data through SNF
```{r}
sc.res <- SNFtool::spectralClustering(W_int_SNF, K=k)
#to have uniform type
sc.res <- pam(sc.res,k=k)
```


#Comparing obtained clusterings with molecular disease subtypes
For each combination of integration method follows a quality evaluation of the possible clusterings in subtypes. A visual idea is given by the plots that represent the separation in clusters of the samples, shown as points extracted with Multidimensional Scaling from the distance matrices given by the used integration method. And, more formally, the clusterings are measured against different indices.

*Chosen indices to measure cluster quality*
* Counting pairs
  * Adjusted Rand index
  * Jaccard index
  * Rand index
* Set overlaps/matching
  * F-measure
* Information theory
  * Joint entropy
  * Normalized Mutual Information (by Strehl & Ghosh)
```{r}
types <- c("adjrand", "jaccard", "rand", "f", "jent",  "nmi1");
```
Convert disease subtypes to numeric vectors:
```{r}
labels <- as.numeric(factor(subtypes$Subtype_Integrative, levels=unique(subtypes$Subtype_Integrative)))
```
##Non-integrated data - clustering with PAM
```{r}
for (i in 1:length(complete))
  clusplot(pam.res[[i]], main ="", cex=0.9, col.p=pam.res[[i]]$cluster, plotchar=FALSE)

```

```{r}
df <- data.frame()
for (i in 1:length(complete)){
  metrics.pam <- mclustcomp(pam.res[[i]]$clustering, labels, types=types);
  scores <- as.list(metrics.pam$scores)
  name <- names(complete)[i]
  df[name] <- scores
}
metrics.pam
df
```
## Data integrated through SNF - clustering with PAM
```{r}
clusplot(pam.SNF.res, main ="", cex=0.9, col.p=pam.SNF.res$cluster, plotchar=FALSE)
```
```{r}
metrics.pam <- mclustcomp(pam.SNF.res$clustering, labels, types=types);

as.data.frame(metrics.pam);
```
## Data integrated though mean - clustering with PAM
```{r}
clusplot(pam.mean.res, main="", cex=0.9, col.p=pam.mean.res$cluster, plotchar=FALSE)
```
```{r}
metrics.pam <- mclustcomp(pam.mean.res$clustering, labels, types=types);

as.data.frame(metrics.pam);
```
## Data integrated through SNF - spectral clustering

```{r}
metrics.pam <- mclustcomp(sc.res$clustering, labels, types=types);

as.data.frame(metrics.pam);
```
```{r}
for (i in 1:length(complete))
  plot(complete[[i]])
```

```{r}
sessionInfo()
```

